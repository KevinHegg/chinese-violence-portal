---
import PageLayout from "../layouts/PageLayout.astro";
import { fetchLynchingsData, fetchLynchingsMainData } from "../utils/googleSheets";

export const prerender = false;

// Fetch lynchings data from both Public and Main tabs
const mainTabGid = import.meta.env.PUBLIC_LYNCHINGS_MAIN_GID || "760826284";
const [publicResult, mainResult] = await Promise.allSettled([
  fetchLynchingsData(),
  fetchLynchingsMainData(mainTabGid)
]);

const publicData = publicResult.status === "fulfilled" ? publicResult.value : [];
const mainData = mainResult.status === "fulfilled" ? mainResult.value : [];

// Merge Main tab data (narrative-short-title, narrative-summary) with Public tab data
// Create a map of Main data by lynching-id for quick lookup
const mainDataMap = new Map();
mainData.forEach((record: any) => {
  if (record["lynching-id"]) {
    mainDataMap.set(record["lynching-id"], record);
  }
});

// Merge: use Public data as base, enrich with Main data where available
const lynchingsData = publicData.map((record: any) => {
  const mainRecord = mainDataMap.get(record["lynching-id"]);
  if (mainRecord) {
    return {
      ...record,
      "decade": mainRecord["decade"] || record["decade"], // Use decade from Main tab
      "narrative-short-title": mainRecord["narrative-short-title"] || record["narrative-short-title"],
      "narrative-summary": mainRecord["narrative-body"] || mainRecord["narrative-summary"] || record["narrative-summary"]
    };
  }
  return record;
});

// Extract unique filter options
// Get decades from Main tab data (gid = 760826284)
const decades = Array.from(new Set(mainData.map((l: any) => l.decade).filter(Boolean))).sort();
const states = Array.from(new Set(lynchingsData.map((l: any) => l.state))).sort();
const eventTypes = Array.from(new Set(lynchingsData.map((l: any) => l["event-type"]))).sort();
const sources = Array.from(new Set(lynchingsData.map((l: any) => l.source))).sort();

// Event Type dropdown: reorder values
const eventTypeOrder = ["Lynching", "Possible Lynching", "Massacre", "Riot"];
const eventTypesSorted = [
  ...eventTypeOrder.filter(type => eventTypes.includes(type)),
  ...eventTypes.filter(type => !eventTypeOrder.includes(type)).sort()
];

// Replace Source filter with Newly Documented filter
const newlyDocumentedOptions = ['Yes', 'No'];
---

<PageLayout title="Explore the Records" currentPage="explore">
  <head>
    <meta name="description" content="Interactively browse, filter, and search anti-Chinese lynching records by decade, state, event type, and more. Discover detailed narratives and patterns in the historical data.">
  </head>
      <div class="container-standard">
    <h1 class="text-4xl font-bold mb-6">Explore the Records</h1>

  <!-- Callout for Submit Form -->
  <div class="mb-6">
    <div class="bg-amber-100 border-l-4 border-amber-400 rounded-lg p-4 flex flex-col md:flex-row md:items-center gap-3 shadow-sm">
      <div class="flex-1 text-amber-900 text-base">
        <strong>Submit details about acts of lethal violence targeting Chinese immigrants in the U.S. between 1850 and World War I.</strong>
      </div>
      <a href="/submit" class="inline-block mt-2 md:mt-0 px-4 py-2 bg-amber-400 hover:bg-amber-500 text-amber-900 font-semibold rounded shadow transition-colors duration-150 text-sm text-center">Submit an Incident</a>
    </div>
  </div>

  <!-- Filter/Search Panel -->
  <div class="bg-amber-50/90 border-2 border-amber-200 rounded-lg p-4 mb-6 shadow-lg">
    <!-- Keyword Search Panel - At Top -->
    <div class="mb-4">
      <div class="bg-white rounded-lg p-3 border border-amber-300 flex items-center gap-4">
        <label for="keyword-search" class="font-medium text-amber-800 whitespace-nowrap">Keyword Search:</label>
        <input id="keyword-search" type="text" class="input input-bordered border-2 border-amber-300 bg-amber-50 flex-1" placeholder="Search titles, summaries..." aria-describedby="keyword-search-hint" />
        <span id="keyword-search-hint" class="sr-only">Search article titles, summaries, and narrative descriptions</span>
        <button id="keyword-clear" class="px-4 py-2 bg-amber-100 hover:bg-amber-200 text-amber-800 font-medium rounded-md shadow-sm hover:shadow-md transition-all duration-200 border border-amber-300 hover:border-amber-400 text-sm whitespace-nowrap" aria-label="Clear keyword search">Clear</button>
      </div>
    </div>
    
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
      <!-- Filter Section -->
      <div class="lg:col-span-2">
        <div class="bg-white rounded-lg p-3 border border-amber-300">
          <h2 class="text-lg font-semibold mb-3 text-amber-800 border-b border-amber-200 pb-2">Filters</h2>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div class="form-control">
              <label class="label">
                <span class="label-text font-medium text-amber-800">Decade</span>
              </label>
              <select id="filter-decade" class="select select-bordered w-full border-2 border-amber-300 bg-amber-50">
                <option value="">All Decades</option>
                {decades.map(decade => <option value={decade}>{decade}</option>)}
              </select>
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text font-medium text-amber-800">State</span>
              </label>
              <select id="filter-state" class="select select-bordered w-full border-2 border-amber-300 bg-amber-50">
                <option value="">All States</option>
                {states.map(state => <option value={state}>{state}</option>)}
              </select>
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text font-medium text-amber-800">Event Type</span>
              </label>
              <select id="filter-eventType" class="select select-bordered w-full border-2 border-amber-300 bg-amber-50">
                <option value="">All Event Types</option>
                {eventTypesSorted.map(type => <option value={type}>{type}</option>)}
              </select>
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text font-medium text-amber-800">Newly Documented</span>
              </label>
              <select id="filter-newlyDocumented" class="select select-bordered w-full border-2 border-amber-300 bg-amber-50">
                <option value="">All</option>
                {newlyDocumentedOptions.map(opt => <option value={opt}>{opt}</option>)}
              </select>
            </div>
          </div>
        </div>
      </div>
      <!-- Sort Section -->
      <div class="h-full flex flex-col justify-start">
        <div class="bg-white rounded-lg p-3 border border-amber-300 h-full">
          <h2 class="text-lg font-semibold mb-3 text-amber-800 border-b border-amber-200 pb-2">Sort Options</h2>
          <div class="form-control">
            <label class="label">
              <span class="label-text font-medium text-amber-800">Sort By</span>
            </label>
            <select id="sort-by" class="select select-bordered w-full border-2 border-amber-300 bg-amber-50">
              <option value="date">Date</option>
              <option value="state">State</option>
            </select>
          </div>
          <div class="form-control mt-3">
            <label class="label">
              <span class="label-text font-medium text-amber-800">Order</span>
            </label>
            <select id="sort-order" class="select select-bordered w-full border-2 border-amber-300 bg-amber-50">
              <option value="asc">Ascending</option>
              <option value="desc">Descending</option>
            </select>
          </div>
        </div>
      </div>
    </div>
    
    <div class="mt-3 flex justify-between items-center">
      <div class="text-sm text-amber-700 bg-amber-100 rounded-lg p-2 flex-1 text-center">
        <span id="results-count">Showing all {lynchingsData.length} records</span>
      </div>
      <button id="clear-filters" class="ml-4 px-4 py-2 bg-amber-100 hover:bg-amber-200 text-amber-800 font-medium rounded-md shadow-sm hover:shadow-md transition-all duration-200 border border-amber-300 hover:border-amber-400 flex items-center gap-2 text-sm" aria-label="Clear all filters and show all records">
        Clear All Filters
      </button>
    </div>
  </div>

  <!-- ARIA live region for dynamic announcements -->
  <div id="results-announcement" aria-live="polite" aria-atomic="true" class="sr-only"></div>

  <!-- Records Cards Grid -->
  <div id="cards-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8" aria-label="Lynching records"></div>
  </div>

</PageLayout>

<script define:vars={{ lynchingsData, mainData }}>
  const data = lynchingsData;
  const container = document.getElementById('cards-container');
  const decadeInput = document.getElementById('filter-decade');
  const stateInput = document.getElementById('filter-state');
  const eventTypeInput = document.getElementById('filter-eventType');
  const sortByInput = document.getElementById('sort-by');
  const sortOrderInput = document.getElementById('sort-order');
  const clearBtn = document.getElementById('clear-filters');
  const resultsCount = document.getElementById('results-count');
  const keywordInput = document.getElementById('keyword-search');
  const keywordClearBtn = document.getElementById('keyword-clear');
  const newlyDocumentedInput = document.getElementById('filter-newlyDocumented');

  let lastKeyword = '';

  function applyFilters() {
    const decade = decadeInput.value;
    const state = stateInput.value;
    const eventType = eventTypeInput.value;
    const newlyDocumented = newlyDocumentedInput.value;
    const keyword = (keywordInput?.value || '').trim().replace(/\s+/g, ' ').toLowerCase();
    lastKeyword = keyword;

    let filtered = data.filter(l => {
      const decadeMatch = !decade || l.decade === decade;
      const stateMatch = !state || l.state === state;
      const eventTypeMatch = !eventType || l['event-type'] === eventType;
      const newlyDocMatch = !newlyDocumented || (newlyDocumented === 'Yes' ? l['newly-documented'] === true || l['newly-documented'] === 'Yes' : l['newly-documented'] === false || l['newly-documented'] === 'No');
      const keywordMatch = !keyword ||
        l['narrative-short-title']?.toLowerCase().includes(keyword) ||
        l['narrative-summary']?.toLowerCase().includes(keyword) ||
        l.state?.toLowerCase().includes(keyword) ||
        l.city?.toLowerCase().includes(keyword) ||
        l.county?.toLowerCase().includes(keyword);
      return decadeMatch && stateMatch && eventTypeMatch && newlyDocMatch && keywordMatch;
    });
    updateFilterOptions();
    renderCards(sortRecords(filtered));
  }

  function updateFilterOptions() {
    // Get current filter values
    const decade = decadeInput.value;
    const state = stateInput.value;
    const eventType = eventTypeInput.value;
    const newlyDocumented = newlyDocumentedInput.value;
    const keyword = (keywordInput?.value || '').trim().replace(/\s+/g, ' ').toLowerCase();
    
    // Count how many dropdown filters are active (not including keyword)
    const activeDropdownCount = [decade, state, eventType, newlyDocumented].filter(Boolean).length;
    
    // Helper to filter records by keyword (searches ENTIRE dataset, ignoring dropdown filters)
    const keywordFilteredRecords = keyword ? data.filter(record => {
      const title = (record['narrative-short-title'] || '').toLowerCase();
      const summary = (record['narrative-summary'] || '').toLowerCase();
      const stateName = (record.state || '').toLowerCase();
      const city = (record.city || '').toLowerCase();
      const county = (record.county || '').toLowerCase();
      return title.includes(keyword) || summary.includes(keyword) || 
             stateName.includes(keyword) || city.includes(keyword) || county.includes(keyword);
    }) : data;
    
    // RULE: Filter ALL dropdowns if keyword is present OR 2+ dropdowns are selected
    // Otherwise (0-1 dropdown, no keyword): selected dropdown keeps all values, others filter
    const filterAllDropdowns = keyword || activeDropdownCount >= 2;
    
    let availableDecades, availableStates, availableEventTypes, availableNewlyDoc;
    
    if (filterAllDropdowns) {
      // ALL dropdowns get filtered based on other selections within keyword-filtered set
      
      // DECADE: filter by state, eventType, newlyDocumented (within keyword results)
      const decadeBase = keywordFilteredRecords.filter(record => {
        const stateMatch = !state || record.state === state;
        const eventTypeMatch = !eventType || record['event-type'] === eventType;
        const newlyDocMatch = !newlyDocumented || (newlyDocumented === 'Yes' ? (record['newly-documented'] === true || record['newly-documented'] === 'Yes') : (record['newly-documented'] === false || record['newly-documented'] === 'No'));
        return stateMatch && eventTypeMatch && newlyDocMatch;
      });
      availableDecades = [...new Set(decadeBase.map(r => r.decade).filter(Boolean))].sort();
      
      // STATE: filter by decade, eventType, newlyDocumented (within keyword results)
      const stateBase = keywordFilteredRecords.filter(record => {
        const decadeMatch = !decade || record.decade === decade;
        const eventTypeMatch = !eventType || record['event-type'] === eventType;
        const newlyDocMatch = !newlyDocumented || (newlyDocumented === 'Yes' ? (record['newly-documented'] === true || record['newly-documented'] === 'Yes') : (record['newly-documented'] === false || record['newly-documented'] === 'No'));
        return decadeMatch && eventTypeMatch && newlyDocMatch;
      });
      availableStates = [...new Set(stateBase.map(r => r.state).filter(Boolean))].sort();
      
      // EVENT TYPE: filter by decade, state, newlyDocumented (within keyword results)
      const eventTypeBase = keywordFilteredRecords.filter(record => {
        const decadeMatch = !decade || record.decade === decade;
        const stateMatch = !state || record.state === state;
        const newlyDocMatch = !newlyDocumented || (newlyDocumented === 'Yes' ? (record['newly-documented'] === true || record['newly-documented'] === 'Yes') : (record['newly-documented'] === false || record['newly-documented'] === 'No'));
        return decadeMatch && stateMatch && newlyDocMatch;
      });
      availableEventTypes = [...new Set(eventTypeBase.map(r => r['event-type']).filter(Boolean))].sort();
      
      // NEWLY DOCUMENTED: filter by decade, state, eventType (within keyword results)
      const newlyDocBase = keywordFilteredRecords.filter(record => {
        const decadeMatch = !decade || record.decade === decade;
        const stateMatch = !state || record.state === state;
        const eventTypeMatch = !eventType || record['event-type'] === eventType;
        return decadeMatch && stateMatch && eventTypeMatch;
      });
      // Check which values exist in filtered set
      const hasYes = newlyDocBase.some(r => r['newly-documented'] === true || r['newly-documented'] === 'Yes');
      const hasNo = newlyDocBase.some(r => r['newly-documented'] === false || r['newly-documented'] === 'No');
      availableNewlyDoc = [];
      if (hasYes) availableNewlyDoc.push('Yes');
      if (hasNo) availableNewlyDoc.push('No');
    } else {
      // Only filter OTHER dropdowns, keep selected dropdown with all values
      
      // Get all possible values for each filter type
      // Decades come from Main tab
      const allDecades = [...new Set(mainData.map(r => r.decade).filter(Boolean))].sort();
      const allStates = [...new Set(data.map(r => r.state).filter(Boolean))].sort();
      const allEventTypes = [...new Set(data.map(r => r['event-type']).filter(Boolean))].sort();
      
      if (decade) {
        // Decade is selected - filter others based on decade
        const filteredByDecade = data.filter(r => r.decade === decade);
        availableDecades = allDecades;
        availableStates = [...new Set(filteredByDecade.map(r => r.state).filter(Boolean))].sort();
        availableEventTypes = [...new Set(filteredByDecade.map(r => r['event-type']).filter(Boolean))].sort();
        const hasYes = filteredByDecade.some(r => r['newly-documented'] === true || r['newly-documented'] === 'Yes');
        const hasNo = filteredByDecade.some(r => r['newly-documented'] === false || r['newly-documented'] === 'No');
        availableNewlyDoc = [];
        if (hasYes) availableNewlyDoc.push('Yes');
        if (hasNo) availableNewlyDoc.push('No');
      } else if (state) {
        // State is selected - filter others based on state
        const filteredByState = data.filter(r => r.state === state);
        availableDecades = [...new Set(filteredByState.map(r => r.decade).filter(Boolean))].sort();
        availableStates = allStates;
        availableEventTypes = [...new Set(filteredByState.map(r => r['event-type']).filter(Boolean))].sort();
        const hasYes = filteredByState.some(r => r['newly-documented'] === true || r['newly-documented'] === 'Yes');
        const hasNo = filteredByState.some(r => r['newly-documented'] === false || r['newly-documented'] === 'No');
        availableNewlyDoc = [];
        if (hasYes) availableNewlyDoc.push('Yes');
        if (hasNo) availableNewlyDoc.push('No');
      } else if (eventType) {
        // Event Type is selected - filter others based on eventType
        const filteredByEventType = data.filter(r => r['event-type'] === eventType);
        availableDecades = [...new Set(filteredByEventType.map(r => r.decade).filter(Boolean))].sort();
        availableStates = [...new Set(filteredByEventType.map(r => r.state).filter(Boolean))].sort();
        availableEventTypes = allEventTypes;
        const hasYes = filteredByEventType.some(r => r['newly-documented'] === true || r['newly-documented'] === 'Yes');
        const hasNo = filteredByEventType.some(r => r['newly-documented'] === false || r['newly-documented'] === 'No');
        availableNewlyDoc = [];
        if (hasYes) availableNewlyDoc.push('Yes');
        if (hasNo) availableNewlyDoc.push('No');
      } else if (newlyDocumented) {
        // Newly Documented is selected - filter others based on newlyDocumented
        const filteredByNewlyDoc = data.filter(r => {
          if (newlyDocumented === 'Yes') {
            return r['newly-documented'] === true || r['newly-documented'] === 'Yes';
          } else {
            return r['newly-documented'] === false || r['newly-documented'] === 'No';
          }
        });
        availableDecades = [...new Set(filteredByNewlyDoc.map(r => r.decade).filter(Boolean))].sort();
        availableStates = [...new Set(filteredByNewlyDoc.map(r => r.state).filter(Boolean))].sort();
        availableEventTypes = [...new Set(filteredByNewlyDoc.map(r => r['event-type']).filter(Boolean))].sort();
        availableNewlyDoc = ['Yes', 'No'];
      } else {
        // No filters selected - show all options
        // Decades come from Main tab, so use mainData
        availableDecades = [...new Set(mainData.map(r => r.decade).filter(Boolean))].sort();
        availableStates = allStates;
        availableEventTypes = allEventTypes;
        availableNewlyDoc = ['Yes', 'No'];
      }
    }
    
    updateSelectOptions(decadeInput, availableDecades, 'All Decades', 'decade');
    updateSelectOptions(stateInput, availableStates, 'All States', 'state');
    updateSelectOptions(eventTypeInput, availableEventTypes, 'All Event Types', 'eventType');
    updateSelectOptions(newlyDocumentedInput, availableNewlyDoc, 'All', 'newlyDocumented');
  }

  function updateSelectOptions(selectElement, availableValues, defaultText, filterType) {
    const currentValue = selectElement.value;
    selectElement.innerHTML = `<option value="">${defaultText}</option>`;
    
    // Get all possible values for this filter type
    let allValues;
    if (filterType === 'eventType') {
      allValues = Array.from(new Set(data.map(l => l['event-type']).filter(Boolean))).sort();
    } else if (filterType === 'newlyDocumented') {
      allValues = ['Yes', 'No'];
    } else if (filterType === 'decade') {
      // Get decades from Main tab data
      allValues = Array.from(new Set(mainData.map(l => l.decade).filter(Boolean))).sort();
    } else {
      allValues = Array.from(new Set(data.map(l => l[filterType]).filter(Boolean))).sort();
    }
    
    // Separate enabled and disabled values
    const enabledValues = [];
    const disabledValues = [];
    
    allValues.forEach(value => {
      if (availableValues.includes(value)) {
        enabledValues.push(value);
      } else {
        disabledValues.push(value);
      }
    });
    
    // Sort enabled values
    enabledValues.sort();
    disabledValues.sort();
    
    // Add enabled options first
    enabledValues.forEach(value => {
      const option = document.createElement('option');
      option.value = value;
      option.textContent = value;
      option.disabled = false;
      selectElement.appendChild(option);
    });
    
    // Add separator if both enabled and disabled exist
    if (enabledValues.length > 0 && disabledValues.length > 0) {
      const separator = document.createElement('option');
      separator.disabled = true;
      separator.textContent = '──────────';
      separator.style.color = '#9ca3af';
      selectElement.appendChild(separator);
    }
    
    // Add disabled options
    disabledValues.forEach(value => {
      const option = document.createElement('option');
      option.value = value;
      option.textContent = value;
      option.disabled = true;
      option.className = 'text-gray-400';
      selectElement.appendChild(option);
    });
    
    // Restore current value if it's still available
    if (currentValue && availableValues.includes(currentValue)) {
      selectElement.value = currentValue;
    } else if (currentValue && !availableValues.includes(currentValue)) {
      selectElement.value = '';
    }
  }

  function sortRecords(records) {
    const sortBy = sortByInput.value;
    const sortOrder = sortOrderInput.value;
    return [...records].sort((a, b) => {
      let aValue, bValue;
      switch (sortBy) {
        case 'date':
          aValue = a.date || '';
          bValue = b.date || '';
          break;
        case 'state':
          aValue = a.state || '';
          bValue = b.state || '';
          break;
        default:
          aValue = a.date || '';
          bValue = b.date || '';
      }
      const cmp = aValue.localeCompare(bValue);
      return sortOrder === 'desc' ? -cmp : cmp;
    });
  }

  // Truncate text to max length at word boundaries
  function truncateAtWordBoundary(text, maxLength) {
    if (!text || text.length <= maxLength) return text || '';
    
    // Find the last space before maxLength
    let truncated = text.substring(0, maxLength);
    const lastSpace = truncated.lastIndexOf(' ');
    
    // If we found a space, truncate there; otherwise truncate at maxLength
    if (lastSpace > 0) {
      truncated = truncated.substring(0, lastSpace);
    }
    
    // Add ellipsis if text was truncated
    return truncated + '...';
  }

  function renderCards(filtered = data) {
    container.innerHTML = '';
    const announcementEl = document.getElementById('results-announcement');
    
    if (filtered.length === 0) {
      resultsCount.textContent = 'No records found';
      if (announcementEl) {
        announcementEl.textContent = 'No records found matching your filters.';
        setTimeout(() => announcementEl.textContent = '', 1000);
      }
      return;
    }
    
    const message = `Showing ${filtered.length} of ${data.length} records`;
    resultsCount.textContent = message;
    if (announcementEl) {
      announcementEl.textContent = message;
      setTimeout(() => announcementEl.textContent = '', 1000);
    }
    
    // Build URL parameters for current filter state
    const params = new URLSearchParams();
    params.set('from', 'explore');
    if (decadeInput.value) params.set('decade', decadeInput.value);
    if (stateInput.value) params.set('state', stateInput.value);
    if (eventTypeInput.value) params.set('eventType', eventTypeInput.value);
    if (newlyDocumentedInput.value) params.set('newlyDocumented', newlyDocumentedInput.value);
    if (sortByInput.value) params.set('sortBy', sortByInput.value);
    if (sortOrderInput.value) params.set('sortOrder', sortOrderInput.value);
    if (keywordInput && keywordInput.value.trim()) params.set('keyword', keywordInput.value.trim());
    
    filtered.forEach(l => {
      const card = document.createElement('a');
      const cardLink = `/records/${l["lynching-id"]}?${params.toString()}`;
      card.href = cardLink;
      card.className = 'block card bg-base-100 shadow-md hover:shadow-lg transition-shadow border border-base-300 p-4 h-full';
      const mapImageSrc = `/mapimages/${l["lynching-id"]}.png`;
      const narrativeSummary = l["narrative-summary"] || '';
      const truncatedSummary = truncateAtWordBoundary(narrativeSummary, 250);
      card.innerHTML = `
        <div class="flex gap-4">
          <div class="flex-shrink-0">
            <img 
              src="${mapImageSrc}" 
              alt="Map showing location of ${l.city || ''}, ${l.state || ''}"
              class="w-24 h-24 object-cover rounded-lg border border-gray-200"
              onerror="this.style.display='none'"
            />
          </div>
          <div class="flex-1 min-w-0">
            <div class="flex justify-between items-center mb-2">
              <span class="text-xs font-semibold text-gray-500">${l.date || ''}</span>
              <span class="text-xs font-semibold text-gray-500">${l.state || ''}</span>
            </div>
            <div class="font-bold text-base mb-1">${l["narrative-short-title"] || l["lynching-id"]}</div>
            <div class="text-sm text-gray-700 summary-fade-container"><span class="summary-fade-text">${truncatedSummary}</span><span class="summary-fade"></span></div>
          </div>
        </div>
      `;
      container.appendChild(card);
    });
  }

  function clearAllFilters() {
    decadeInput.value = '';
    stateInput.value = '';
    eventTypeInput.value = '';
    newlyDocumentedInput.value = '';
    sortByInput.value = 'date';
    sortOrderInput.value = 'asc';
    if (keywordInput) keywordInput.value = '';
    updateFilterOptions();
    applyFilters();
  }

  if (decadeInput) decadeInput.addEventListener('change', applyFilters);
  if (stateInput) stateInput.addEventListener('change', applyFilters);
  if (eventTypeInput) eventTypeInput.addEventListener('change', applyFilters);
  if (newlyDocumentedInput) newlyDocumentedInput.addEventListener('change', applyFilters);
  if (sortByInput) sortByInput.addEventListener('change', applyFilters);
  if (sortOrderInput) sortOrderInput.addEventListener('change', applyFilters);
  if (clearBtn) clearBtn.addEventListener('click', clearAllFilters);
  if (keywordInput) {
    keywordInput.addEventListener('input', (e) => {
      // Only trigger if the trimmed, single-spaced value actually changes
      const newKeyword = (e.target.value || '').trim().replace(/\s+/g, ' ').toLowerCase();
      if (newKeyword !== lastKeyword) {
        applyFilters();
      }
    });
  }
  if (keywordClearBtn) {
    keywordClearBtn.addEventListener('click', () => {
      if (keywordInput) keywordInput.value = '';
      applyFilters();
    });
  }
  // Restore filter state from URL parameters if present
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('decade')) decadeInput.value = urlParams.get('decade');
  if (urlParams.has('state')) stateInput.value = urlParams.get('state');
  if (urlParams.has('eventType')) eventTypeInput.value = urlParams.get('eventType');
  if (urlParams.has('newlyDocumented')) newlyDocumentedInput.value = urlParams.get('newlyDocumented');
  if (urlParams.has('sortBy')) sortByInput.value = urlParams.get('sortBy');
  if (urlParams.has('sortOrder')) sortOrderInput.value = urlParams.get('sortOrder');
  if (urlParams.has('keyword') && keywordInput) keywordInput.value = urlParams.get('keyword');

  // Always apply filters after restoring controls (even if no params)
  applyFilters();

  window.addEventListener('pageshow', () => {
    // Re-apply filter/sort/keyword logic to the card grid and controls
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('decade')) decadeInput.value = urlParams.get('decade');
    else decadeInput.value = '';
    if (urlParams.has('state')) stateInput.value = urlParams.get('state');
    else stateInput.value = '';
    if (urlParams.has('eventType')) eventTypeInput.value = urlParams.get('eventType');
    else eventTypeInput.value = '';
    if (urlParams.has('newlyDocumented')) newlyDocumentedInput.value = urlParams.get('newlyDocumented');
    else newlyDocumentedInput.value = '';
    if (urlParams.has('sortBy')) sortByInput.value = urlParams.get('sortBy');
    else sortByInput.value = 'date';
    if (urlParams.has('sortOrder')) sortOrderInput.value = urlParams.get('sortOrder');
    else sortOrderInput.value = 'asc';
    if (urlParams.has('keyword') && keywordInput) keywordInput.value = urlParams.get('keyword');
    else if (keywordInput) keywordInput.value = '';
    applyFilters();
  });
</script>
<style>
  select option:disabled {
    color: #9ca3af;
    font-style: italic;
  }
  .summary-fade-container {
    position: relative;
    max-height: 120px;
    overflow: hidden;
  }
  .summary-fade-text {
    display: block;
    margin-bottom: 0;
  }
  .summary-fade {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 40px;
    background: linear-gradient(transparent, #ffffff);
    pointer-events: none;
    width: 100%;
    z-index: 2;
  }
</style>
